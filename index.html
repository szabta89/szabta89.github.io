<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
		<meta name="Keywords" content="Tamas Szabo, Tamás Szabó, TU Delft, itemis, Language Workbench, DSL, Static Analysis, Data-flow, MPS, Language Engineering" />
		<meta name="Distribution" content="Global" />
		<meta name="Robots" content="index,follow" />
		<link rel="shortcut icon" href="favicon.ico"/>
		<link rel="stylesheet" type="text/css" href="css/main.css"/>
		
		<title>Tamás Szabó personal homepage</title>
		<script type="text/javascript" src="https://code.jquery.com/jquery-latest.js"></script>
		<script type="text/javascript" src="js/moretext.js"></script>
	</head>
	<body>
		<div id="main">
			<div class="header">
				<div class="mark">
					<span class="uw">Tamás Szabó</span>
				</div>
				<div id="title">personal homepage</div>
				<br/>
			</div>
			<div class="content">
				<div class="paper project">
					<div class="thumbnail">
						<div class="desc">
							<p align="justify">I am a PhD student in the <a href="http://eelcovisser.org/wiki/group">Software Engineering Research Group</a> 
								of TU Delft under the supervision of <a href="http://erdweg.org/index.html">Sebastian Erdweg</a>. I carry out my 
								research work at the company <a href="https://www.itemis.com">itemis</a>, where I work since 2013, and I am a member of the 
								Language Engineering team in Stuttgart. My supervisor is <a href="http://www.voelter.de/">Markus Völter</a> from the itemis side.</p>

							<p align="justify">My research mainly focuses on language support for incremental and parallel computations, but I am generally interested 
								in the various aspects of programming language design and implementation; compilers, static analysis, and language workbenches.</p>

							<p align="justify">I have obtained my B.Sc. and M.Sc. degrees from the Technical University of Budapest, 
								where I have worked in the <a href="https://inf.mit.bme.hu/en">Fault Tolerant Systems Research Group</a>. I maintain long standing collaborations with the group, and 
								I frequently work together ever since with <a href="https://inf.mit.bme.hu/en/members/rath">István Ráth</a>.</p>

							<p align="justify">You can find further information on this page about the projects I am involved in, the list of my publications 
								and talks, and you can also take a look at my <a href="cv/tamas_szabo_cv_en.pdf">CV</a>.</p>

						</div>
					</div>

					<div class="thumbnail">
						<p><img src="images/me.jpg"/></p>
						<p>email: <a href="mailto:tamas.szabo@itemis.de">tamas.szabo [at] itemis.de</a><br>
						twitter: <a href="https://twitter.com/szabta89">@szabta89</a><br>
						github: <a href="https://github.com/szabta89">https://github.com/szabta89</a></p>
					</div>
				</div>

				<div style="clear:both"></div>
				<div class="header">
					<div class="lead">Publications</div><button class="ShowHideAll">Show abstracts</button>
				</div>
				
				<div class="paper project">
					<p id="Szabo16">
						<b>Dedicated Support for Analyses and Optimizations in Language Workbenches</b><br/>
						<b>Tamás Szabó</b>.<br/>
						In <em>Proceedings of Systems, Programming, Languages, and Applications: Software for Humanity (SPLASH) - Doctoral Symposium</em>, ACM, 2016.
						[&nbsp;<a href="publications/diss-plan.pdf">pdf</a>&nbsp;]
						<blockquote>
							<p align="justify">
								Language workbenches are widely used to implement domain-specific languages (DSLs) 
								and their accompanying integrated development environments (IDEs). They help to define 
								the abstract syntax, concrete syntax(es), type system, and transformations for the languages. 
								However, there are other language aspects, specifically program analyses and optimizations, 
								that are also crucial to a language implemen- tation, but state-of-the-art language workbenches 
								has only limited support for them. The high implementation effort for these language aspects 
								is justifiable for a general-purpose language (GPL), but is not justifiable for DSLs because 
								of their different development economies.
							</p>
							<p align="justify">
								To this end, I conduct research on dedicated support for analyses and optimizations for DSLs 
								in language workbenches. My main goal is to develop declarative meta-languages that help to 
								define static program analyses and that capture and automate patterns and techniques of optimizations. 
								The research directions are directly driven by industrial need, and upon successful completion, 
								the results would be applied in projects centered around DSLs for high-performance computing (HPC), 
								insurance, and concurrent embedded systems.
							</p>
						</blockquote>
					</p>
					<p id="SzaboEV16">
						<b>Efficient Development of Consistent Projectional Editors using Grammar Cells</b><br/>
						Markus Völter, <b>Tamás Szabó</b>, Sascha Lisson, Bernd Kolb, Sebastian Erdweg, and Thorsten Berger.<br/>
						In <em>Proceedings of Software Language Engineering (SLE)</em>, ACM, 2016.
						[&nbsp;<a href="publications/gc-sle.pdf">pdf</a>&nbsp;]
						<blockquote>
							<p align="justify">
								The definition of a projectional editor does not just specify the notation of a 
								language, but also how users interact with the notation. Because of that it is 
								easy to end up with different interaction styles within one and between multiple 
								languages. The resulting inconsistencies have proven to be a major usability problem. 
								To address this problem, we introduce grammar cells, an approach for declaratively 
								specifying textual notations and their interactions for projectional editors. 
								In the paper we motivate the problem, give a formal definition of grammar cells, 
								and define their mapping to low-level editor behaviors. Our evaluation based 
								on project experience shows that grammar cells improve editing experience by 
								providing a consistent and intuitive, “text editor-like” user experience for 
								textual notations. At the same time they do not limit language composability 
								and the use of non-textual notations, the primary benefits of projectional 
								editors. We have implemented grammar cells for Jetbrains MPS, but they can also 
								be used with other projectional editors.
							</p>
						</blockquote>
					</p>
					<p id="SzaboEV16">
						<b>IncA: A DSL for the Definition of Incremental Program Analyses</b><br/>
						<b>Tamás Szabó</b>, Sebastian Erdweg, and Markus Voelter.<br/>
						In <em>Proceedings of International Conference on Automated Software Engineering (ASE)</em>, ACM, 2016.
						[&nbsp;<a href="publications/inca-ase.pdf">pdf</a>&nbsp;]
						<blockquote>
							<p align="justify">
								Program analyses support software developers, for example, through error 
								detection, code-quality assurance, and by enabling compiler optimizations 
								and refactorings. To provide real-time feedback to developers within IDEs, 
								an analysis must run efficiently even if the analyzed code base is large.
							</p>
							<p align="justify">
								To achieve this goal, we present a domain-specific language called IncA for 
								the definition of efficient incremental program analyses that update their 
								result as the program changes. IncA compiles analyses into graph patterns 
								and relies on existing incremental matching algorithms. To scale IncA analyses 
								to large programs, we describe optimizations that reduce caching and prune 
								change propagation. Using IncA, we have developed incremental control flow 
								and points-to analysis for C, well-formedness checks for DSLs, and 10 FindBugs 
								checks for Java. Our evaluation demonstrates significant speedups for all analyses 
								compared to their non-incremental counterparts.
							</p>
						</blockquote>
					</p>
					<p id="SzaboAVE16">
						<b>An Extensible Framework for Variable-Precision Data-Flow Analyses in MPS</b><br/>
						<b>Tamás Szabó</b>, Simon Alperovich, Markus Voelter, and Sebastian Erdweg.<br/>
						In <em>Proceedings of International Conference on Automated Software Engineering (ASE) - Tool Track</em>, ACM, 2016.
						[&nbsp;<a href="publications/mps-df-ase.pdf">pdf</a>&nbsp;]
						<blockquote>
							<p align="justify">
								Data-flow analyses are used as part of many software engineering
								tasks: they are the foundations of program understanding, refactorings
								and optimized code generation. Similar to general-purpose languages
								(GPLs), state-of-the-art domain-specific languages (DSLs) also require
								sophisticated data-flow analyses.  However, as a consequence of the
								different economies of DSL development and their typically relatively
								fast evolution, the effort for developing and evolving such analyses
								must be lowered compared to GPLs.  This tension can be resolved with
								dedicated support for data-flow analyses in language workbenches.
							</p>
							<p align="justify">
								In this tool paper we present MPS-DF, which is the component in the MPS
								language workbench that supports the definition of data-flow analyses
								for DSLs. Language developers can define data-flow graph builders
								declaratively as part of a language definition and compute analysis
								results efficiently based on these data-flow graphs. MPS-DF is
								extensible such that it does not compromise the support for language
								composition in MPS. Additionally, clients of MPS-DF analyses can run the
								analyses with variable precision thus trading off precision for
								performance. This allows clients to tailor an analysis to a particular
								use case.
							</p>
						</blockquote>
					</p>
					<p id="SzaboVKRS2014">
						<b>mbeddr: Extensible Languages for Embedded Software Development</b><br/>
						<b>Tamás Szabó</b>, Markus Voelter, Bernd Kolb, Daniel Ratiu, Bernhard Schaetz.<br/>
						In <em>Proceedings of High Integrity Language Technology (HILT)</em>, ACM, 2014.
						[&nbsp;<a href="publications/mbeddr-hilt.pdf">pdf</a>&nbsp;]
						<blockquote>
							<p align="justify">
								In this industrial presentation we will demonstrate mbeddr,
								an extensible set of integrated languages for embedded software
								development. After discussing the context of the talk,
								we will give details about the mbeddr architecture, which
								relies on the MPS language workbench. Then, we will elaborate
								on the extension modules and show how they fit with
								safety-critical development processes. Finally, we will point
								out how the existing languages can be extended by the user
								by giving some real-world examples, including a language
								construct that could have prevented the Apple “goto fail”
								bug as well as mathematical notations.
							</p>
						</blockquote>
					</p>
					<p id="UjhelyiSRV2012">
						<b>Developing and Visualizing Live Model Queries</b><br/>
						Zoltán Újhelyi, <b>Tamás Szabó</b>, István Ráth, Dániel Varró.<br/>
						In <em>Proceedings of Analysis of Model Transformations (AMT)</em>, ACM, 2012.
						[&nbsp;<a href="publications/incquery-qe-amt.pdf">pdf</a>&nbsp;]
						<blockquote>
							<p align="justify">
								Several important tasks performed by model driven development tools — 
								such as well-formedness constraint validation or model transformations — 
								rely on evaluating model queries. If the model changes rapidly or frequently, 
								it is beneficial to provide live queries that automatically propagate 
								these model changes into the query results. To ease the development and 
								debugging of live queries, the development environment should provide a 
								way to evaluate the query results continuously, helping to understand how the created query works.
							</p>
							<p align="justify">
								This paper presents a generic live model query visualizer that displays 
								and updates the query results depending on their source models. It has 
								been implemented for the EMF-IncQuery framework and presented here 
								for validating BPMN models.
							</p>
						</blockquote>
					</p>
					<p id="BergmannRSTV2012">
						<b>Incremental pattern matching for the efficient computation of transitive closure</b><br/>
						Gábor Bergmann, István Ráth, <b>Tamás Szabó</b>, Paolo Torrini, Dániel Varró.<br/>
						In <em>Proceedings of International Conference on Graph Transformations (ICGT)</em>, Springer-Verlag, 2012.
						[&nbsp;<a href="publications/incquery-tc-icgt.pdf">pdf</a>&nbsp;]
						<blockquote>
							<p align="justify">
								Pattern matching plays a central role in graph transformations as a key 
								technology for computing local contexts in which transformation rules are to be applied. 
								Incremental matching techniques offer a performance advantage over the search-based approach, 
								in a number of scenarios including on-the-fly model synchronization, model simulation, 
								view maintenance, well-formedness checking and state space traversal. However, the incremental 
								computation of transitive closure in graph pattern matching has started to be investigated 
								only recently. In this paper, we propose multiple algorithms for the efficient computation of 
								generalized transitive closures. As such, our solutions are capable of computing reachability 
								regions defined by simple graph edges as well as complex binary relationships defined by 
								graph patterns, that may be used in a wide spectrum of modeling problems. We also report on 
								experimental evaluation of our prototypical implementation, carried out within the context 
								of a stochastic system simulation case study.
							</p>
						</blockquote>
					</p>
					<p id="VorosSJDHB2011">
						<b>Parallel Saturation Based Model Checking</b><br/>
						András Vörös, <b>Tamás Szabó</b>, Attila Jámbor, Dániel Darvas, Ákos Horváth, Tamás Bartha.<br/>
						In <em>Proceedings of International Symposium on Parallel and Distributed Computing (ISPDC)</em>, IEEE, 2011.
						[&nbsp;<a href="publications/petridotnet-ispdc.pdf">pdf</a>&nbsp;]
						<blockquote>
							<p align="justify">
								Formal verification is becoming a fundamental step
								of safety-critical and model-based software development. As
								part of the verification process, model checking is one of the
								current advanced techniques to analyze the behavior of a
								system. In this paper, we examine an existing parallel model
								checking algorithm and we propose improvements to eliminate
								some computational bottlenecks. Our measurements show that
								the resulting new algorithm has better scalability and
								performance than both the former parallel approach and the
								sequential algorithm.
							</p>
						</blockquote>
					</p>
				</div>

				<div style="clear:both"></div>

				<div class="header">
					<div class="lead">Projects</div>
				</div>

				<div class="paper project">
					<div class="thumbnail">
						<div class="desc">
							<a href="https://www.eclipse.org/incquery"><img src="images/eiq.png"/></a>
							<p align="justify">
								EMF-IncQuery is a high-performance framework for incremental graph pattern matching over EMF models. It comes with an expressive declarative 
								language to define patterns over the models and the query engine incrementally processes the changes of the model to keep the query results 
								up-to-date. In the context of the project, I have developed the dedicated transitive closure support and implemented the Query Explorer component 
								which is widely used to debug the graph patterns during development.
							</p>
						</div>
					</div>
					<div class="thumbnail">
						<div class="desc">
							<a href="https://szabta89.github.io/projects/inca.html"><img src="images/inca.png"/></a>
							<p align="justify">
								IncA is a program analysis framework. It comes with a DSL for the definition of program analyses 
								and the runtime system evaluates program analyses incrementally to achieve the performance that is needed for 
								real-time feedback in IDEs. When code gets changed, the IncA runtime system incrementally updates the results instead of 
								the repeated recomputation from scratch. IncA program analysis code is translated into graph patterns and we reuse existing incremental 
								graph pattern matching solutions to evaluate the analysis code on the AST of the analyzed program.
							</p>
						</div>
					</div>
					<div class="thumbnail">
						<div class="desc">
							<a href="http://www.mbeddr.com"><img src="images/mbeddr.png"/></a>
							<p align="justify">mbeddr is a set of integrated and extensible languages for embedded software engineering, plus an IDE.
								It is built on top of the MPS language workbench which gives a high degree of flexibility and extensibility 
								in terms of the set of languages, tool integrations and notations for concrete syntax. I have made numerous contributions 
								to the core mbeddr languages as well as extensions to those; physical units and the mbeddr importer.</p>
						</div>
					</div>
					<div class="thumbnail">
						<div class="desc">
							<a href="https://github.com/franca/franca"><img src="images/franca.png"/></a>
							<p align="justify">Franca is a powerful framework for definition and transformation of software interfaces. 
								It is used for integrating software components from different suppliers, which are built based on various runtime frameworks, 
								platforms and IPC mechanisms. The core of it is Franca IDL (Interface Definition Language), which is a textual language for 
								specification of APIs.</p>
						</div>
					</div>
				</div>
			</div>
			<div style="clear:both">
				<div class="footer">
					Page was generated from <a href="https://github.com/szabta89/szabta89.github.io">github.com/szabta89/szabta89.github.io</a>. 
				</div>
			</div>
		</div>
		<script type="text/javascript">

			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-44428446-5', 'auto');
			ga('send', 'pageview');

			ga('create', 'UA-48049134-5', 'auto', {'name': 'arvindsatya1'});
			ga('arvindsatya1.send', 'pageview');
		</script>
	</body>
</html>