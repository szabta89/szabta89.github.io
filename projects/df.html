<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <title>An Extensible Framework for Variable-precision Data-flow Analyses in MPS</title>
    <link rel="shortcut icon" href="favicon.ico"/>
    <link rel="stylesheet" type="text/css" href="../css/main.css"/>
</head>
<body>
<div id="main">

    <div class="header">
        <div class="mark">
            <span class="uw">MPS-DF</span>
        </div>
        <div id="title">project overview</div>
        <br/>
    </div>
    <div class="content">
        <p align="justify">MPS-DF is the data-flow support in the MPS language workbench. It supports the definition 
        and efficient execution of <b>data-flow analyses</b>. Users of MPS-DF first define <b>data-flow builders</b> for the analyzed 
        language. These builders contribute subgraphs to the <b>data-flow graph (DFG)</b>, an intermediate program representation 
        encoding the data-flow of the analyzed program. MPS-DF then supports defining data-flow analyses, on the DFG, which 
        compute some data-flow specific knowledge (e.g. which variables are initialized) about the program. These data-flow 
        analyses are static program analyses, which derive the knowl- edge without actually running the analyzed program. Finally, 
        existing MPS components, such as program validators, transformations or refactorings, make use of this knowledge.</p>
        
        <p>
        MPS-DF has two important characteristics: extensibility and variable precision.
        <ul>
        	<li align="justify"><b>Extensibility</b> is motivated by the fact that MPS-based languages are extensible themselves (wrt. syntax, semantics, IDE support). 
        	It comes in two flavours: first, builders enable extensibility of the DFG in the face of language extensions of the analyzed language. 
        	This means that an existing analysis immediately works on an extended program if the concepts in the language extension also define 
        	builders and thus contribute subgraphs to the DFG. The second flavour of extensibility supports augmenting the DFG for a particular 
        	analysis with custom nodes that encode specific knowledge about the analyzed program and potentially override an analysis result based on that knowledge.</li>
        	<li align="justify"><b>Variable precision</b> considers performance trade-offs: real-time checks in the IDE must run fast, possibly compromising on precision, 
        	whereas a more precise, but slower, analysis is needed during compilation. We achieve the variable precision by switching between 
        	intra-procedural analysis (within a sin- gle function definition) and inter-procedural analysis (across function definitions). 
        	Switching is achieved by constructing two different DFGs, but running the same analyses.</li>
        </ul>
        </p>
        
    </div>

    <div class="paper project">
        <div class="thumbnail">
            <div class="desc">
                <h3>Table of contents:</h3>
                <ol>
                    <li><a href="#claims">Highlights of the project</a></li>
                    <li><a href="#start">Getting Started</a></li>
                    <li><a href="#case_studies">Case studies</a></li>
                    <li><a href="#evaluation">Evaluation</a></li>
                </ol>
            </div>
        </div>
        <div class="thumbnail">
            <div class="desc">
                <h3>Software Requirements:</h3>
                <ul>
                    <li><a href="https://drive.google.com/folderview?id=0B7n4tuU3Ty7eZkZCNFQ4RDBSdDg&usp=sharing">MPS 3.3.4</a></li>
                    <li>Java 1.8</li>
                    <li><a href="https://www.mbeddr.com">mbeddr</a> for the inter-procedural analyses and the case studies</li>
                </ul>
            </div>
        </div>
    </div>

    <div style="clear:both"></div>

    <div class="content">
        <h2 id="claims">1 - Highlights</h2>
        <ul>
            <li align="justify">MPS-DF provides a DSL for the definition of data-flow graph builders. Builders contribute subgraphs to the data-flow graph, 
                which is an intermediate program representation encoding the control flow of the program together with the data-flow.</li>
            <li align="justify">MPS-DF provides a DSL for the definition of data-flow analyses which derive some data-flow specific knowledge on the DFG of the analyzed program.</li>
            <li align="justify">MPS-DF provides extensive support for extensibility which aligns perfectly with the support for language extensions in MPS.</li>
            <li align="justify">Data-flow analyses can be evaluated with varying precision levels; clients can switch between a more precise and potentially slower inter-procedural 
                analysis and a less precise but faster intra-procedural analysis. </li>
            <li align="justify">Results of MPS-DF analyses can immediately be used in already existing MPS components: validation rules, generators, refactorings.</li>
        </ul>
        
        The following video also highlights the various aspects of the project:
		<object width="420" height="315" data="https://www.youtube.com/embed/laNDAZCe2jM"></object>
    </div>

    <div class="content">
        <h2 id="start">2 - Getting Started</h2>

        <p align="justify">
        At the time of the ASE submission only the intra-procedural part of MPS-DF is integrated into MPS. The inter-procedural part is 
        part of the mbeddr project and it is being integrated into core MPS during the summer. The plan is that the upcoming major release of 
        MPS (version 3.4) will already contain all MPS-DF components. </p>
        
        <p align="justify">You can download the corresponding MPS version from <a href="https://drive.google.com/folderview?id=0B7n4tuU3Ty7eZkZCNFQ4RDBSdDg&usp=sharing">here</a> 
        and you may find the <a href="https://confluence.jetbrains.com/display/MPSD33/MPS+User's+Guide">MPS user guide</a> interesting as well.</p>
        
		<p align="justify">You can obtain the inter-procedural part along with the case studies from the <a href="https://www.mbeddr.com">mbeddr</a> repository. Simply check out the <code>feature/mps-df</code> branch which 
		also contains the example projects used in the paper and in the above video for demonstration. The relevant MPS modules for the inter-procedural 
		data-flow analyses are the <code>com.mbeddr.mpsutil.dataflow</code> language and the <code>com.mbeddr.mpsutil.dataflow.runtime</code> solution from the mpsutil project in mbeddr. </p>

        <p class="content">
        <h2 id="case_studies">3 - Case studies </h2>
        <h3>Case study 1 - Inter-procedural Initialized Variables Analyses [<a href="df/InitializedVars.pdf">pdf</a>][<a href="df/InitializedVars.txt">text</a>]</h3>
        Initialized variable analyses finds variables that are not initialized in the moment of reading and lets the
        corresponding checking rule highlight them as errors.
        <p>Its lattice is defined as <code>set< node < Var > ></code> and it encodes the set of definitely initialized
            variables at a program point.</p>
        <p>
            The <b>forward</b> direction specifies that the analyses traversing of the program starts at the first
            instruction
        </p>
        <p>
            The <code>fun</code> function builds the set of variables for every node in the DFG.
        </p>
        <p>When <code>fun</code> encounters a <code>write</code> instruction in the DFG, it adds the written variable to
            the set because that variable is now definitely initialized.</p>
        <p>When <code>fun</code> encounters a <code>defInit</code> instruction it adds the definitely initialized
            variable to the set because, by the meaning of the instruction, the variable is initialized.</p>
        <p>The merge function uses intersection for this particular analysis, because we build a must analysis which
            considers a variable initialized only if it is initialized on all incoming execution paths.</p>
        <p>
            You can find the it's declaration in "<code>InitializedVariablesAnalyzer</code>" root in <code>com.mbeddr.core.modules.dataFlow</code>
            model
        <p>
        <h3>Case study 2 - Intra-procedural Nullable Analyses [<a href="df/Nullable.pdf">pdf</a>][<a href="df/Nullable.txt">text</a>]</h3>
        Nullable analyses finds variables that could be null at the point they should not be, i.e at the method call.
        <p>This Analyses is forward same as Initialized variable analyses from case study 1.</p>
        Its lattice is defined as <code>map< node, NullableState></code> and it encodes the state of each expression and variable on
        each program point.
        Nullable state can be one of the follows: NOTNULL, NULL, NULLABLE, UNKNOWN, NOT_INIT.
        <p>
            <code>NOTNULL</code> - means that expression is definitely not null at this program point.
        <p>
            <code>NULL</code> - definitely null.
        <p>
            <code>NULLABLE</code> - expression can be null.
        <p>
            <code>UNKNOWN</code> - no definite information could be told.
        <p>
            <code>NOT_INIT</code>- variable is not initialized.
        <p>

            Analyses uses three custom instructions: <code>nullable</code>, <code>notNull</code> and <code>null</code>
            with the parameter of expression.

        <p><code>nullable</code> is inserted to the graph i.e. when variable is annotated with the<code>@Nullable</code> annotation.
        <p><code>notNull</code> is inserted i.e. if variable is annotated with the <code>@NotNull</code> annotation or
            the variable is assigned to the definitely not null expression.</p>
        <p><code>null</code> is inserted for the <code>null</code> literals.</p>
        <p>

        <p>The <code>fun</code> function assigns the <code>UNKNOWN</code> state to the expression if the instruction is not one of the three custom.</p>
        <p>It assigns the corresponding <code>NOTNULL</code>, <code>NULL</code> or <code> NULLABLE</code> state to the expression if the instruction is either
            <code>notNull</code>, <code>null</code> or <code>nullable</code></p>
        <p>The <code>fun</code> function encounters <code>write</code> instruction, it assigns the state of the expression to the written variabl</p>
        <p>The <code>merge</code> function reduces the information about the state. I.e. it returns <code>NULL</code> or <code>NOTNULL</code> only if in
        both paths state of the expression is correspondingly <code>NULL</code> or <code>NOTNULL</code>. Otherwise it will return <code>NULLABLE</code></p>


        <p>
            You can find the it's declaration in "NullableAnalyzer" root in
            <code>jetbrains.mps.baseLanguage.dataFlow</code> model

    </div>

    <div class="content">
        <h2 id="evaluation">5 - Evaluation</h2>
        The common case for evaluating the data-flow analysis is checking the program and highlighting the errors.
        In MPS it is done in checking rules of <a href="https://confluence.jetbrains.com/display/MPSD33/Typesystem">typesystem</a>.
        MPS provides the API for evaluating either common analysis i.e.uninitialized reads, unreachable instructions and
        unused assignments or custom analyses.
        The common analysis could be evaluated via building the program with MPSProgramBuilder.buildProgram() method
        and passing the result to the util class DataFlow.
        <p>
        The custom analyses can be evaluate with the special construction "analyzerRunner". To use this construction you
        need to import language jetbrains.mps.lang.dataDlow.analyzers
        </p>
        The examples of evaluating the case studies could be found at <code>InitializedVariablesAnalyzerHelper</code> and at <code>check_NullableStates</code> checking rule.
    </div>


</div>

<div style="clear:both"></div>
<div class="footer">
    Page was generated from <a href="https://github.com/szabta89/szabta89.github.io">github.com/szabta89/szabta89.github.io</a>.
</div>
</div>
<script type="text/javascript">
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
                    (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date();
        a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-44428446-5', 'auto');
    ga('send', 'pageview');

    ga('create', 'UA-48049134-5', 'auto', {'name': 'arvindsatya1'});
    ga('arvindsatya1.send', 'pageview');
</script>
</body>
</html>
